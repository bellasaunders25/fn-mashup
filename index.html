<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fortnite V39.0 - Audio & Storm Fix</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Russo One', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

        .fn-text { text-transform: uppercase; transform: skewX(-10deg); text-shadow: 2px 2px 0px #000; }
        :root { --gold: #ffe400; --purple: #bd00ff; --blue: #00aaff; --red: #ff3333; }

        /* --- TITLE --- */
        #title-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #7000df 0%, #100030 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 3000;
        }
        #fortnite-logo {
            font-size: 120px; color: white; letter-spacing: -5px; margin-bottom: 20px;
            text-shadow: 0 10px 0 rgba(0,0,0,0.3); transform: skewX(-5deg) rotate(-3deg);
        }
        #start-btn {
            background: var(--gold); color: #000; border: 4px solid white;
            padding: 20px 80px; font-size: 30px;
            font-family: 'Russo One', sans-serif;
            text-transform: uppercase; transform: skewX(-10deg);
            cursor: pointer;
            box-shadow: 0 10px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s, box-shadow 0.1s, filter 0.15s;
        }
        #start-btn:hover {
            filter: brightness(1.1);
            transform: skewX(-10deg) translateY(-2px);
        }
        #start-btn:active {
            transform: skewX(-10deg) translateY(5px);
            box-shadow: 0 5px 0 rgba(0,0,0,0.2);
        }

        /* --- LOBBY --- */
        #lobby-screen {
            position: absolute; inset: 0;
            display: none;
            flex-direction: column;
            padding: 16px 26px 18px 26px;
            box-sizing: border-box;
            background: radial-gradient(circle at top, #3e7bff 0%, #1c38a0 40%, #02061a 100%);
            color: #fff;
            z-index: 2000;
        }

        #lobby-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 10px;
        }
        #lobby-title {
            font-size: 22px;
            letter-spacing: 3px;
        }
        #lobby-tabs {
            display: flex;
            gap: 24px;
            font-size: 14px;
        }
        #lobby-tabs span {
            opacity: 0.75;
            cursor: pointer;
            position: relative;
        }
        #lobby-tabs span:first-child {
            opacity: 1;
            color: var(--gold);
        }
        #lobby-tabs span:first-child::after {
            content: "";
            position: absolute;
            left: 0; right: 0; bottom: -4px;
            height: 3px;
            background: var(--gold);
        }

        #lobby-main {
            flex: 1;
            display: flex;
            margin-top: 10px;
            gap: 20px;
        }

        /* PARTY / SQUAD AREA */
        #lobby-party {
            position: relative;
            flex: 1.2;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 18px;
        }

        .party-slot {
            position: relative;
            width: 18%;
            max-width: 190px;
            height: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }

        .party-banner {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 82%;
            border-radius: 12px 12px 0 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(0,0,0,0.25));
            box-shadow: 0 12px 30px rgba(0,0,0,0.7);
        }
        .banner-pink  { background: linear-gradient(180deg,#ff85d1,#ff4f7d); }
        .banner-yellow{ background: linear-gradient(180deg,#ffe66c,#ffb92b); }
        .banner-teal  { background: linear-gradient(180deg,#4fe4ff,#008dff); }
        .banner-purple{ background: linear-gradient(180deg,#c07bff,#6a44ff); }

        .party-center .party-banner {
            transform: scale(1.15);
            transform-origin: bottom center;
        }

        .party-character {
            position: relative;
            width: 100%;
            height: 72%;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            pointer-events: none;
        }

        .party-stand {
            position: absolute;
            bottom: 0;
            width: 120%;
            height: 18%;
            border-radius: 50%;
            background: radial-gradient(circle at top, #ffffff, #c0ddff);
            box-shadow: 0 0 40px rgba(0,0,0,0.7);
        }

        .party-empty {
            opacity: 0.45;
        }

        .party-footer {
            position: relative;
            margin-top: 6px;
            text-align: center;
            font-size: 13px;
        }
        .party-name {
            font-size: 16px;
            letter-spacing: 1px;
        }
        .party-state {
            font-size: 11px;
            opacity: 0.8;
        }

        /* Skin switcher under center card */
        #skin-switcher {
            position: absolute;
            bottom: 6%;
            left: 50%;
            transform: translateX(-50%) skewX(-10deg);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0,0,0,0.45);
            border: 2px solid rgba(255,255,255,0.75);
            padding: 4px 12px;
            font-size: 13px;
        }
        #skin-name {
            min-width: 80px;
            text-align: center;
        }
        .skin-arrow {
            cursor: pointer;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 16px;
            padding: 0 4px;
        }

        /* RIGHT HUD SIDE (SEASON / PLAY) */
        #lobby-side {
            flex: 0.7;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #lobby-season-card {
            background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.2));
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.25);
            padding: 12px 16px;
            font-size: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }
        #lobby-season-card h3 {
            margin: 0 0 4px 0;
            font-size: 14px;
        }
        .season-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 2px 0;
        }
        .xp-bar {
            height: 6px;
            border-radius: 999px;
            background: rgba(255,255,255,0.15);
            overflow: hidden;
            margin-top: 4px;
        }
        .xp-fill {
            width: 40%;
            height: 100%;
            background: linear-gradient(90deg,#7cffb2,#00ffea);
        }
        .challenge-row {
            display:flex; justify-content:space-between; font-size:11px; opacity:.85;
        }

        #lobby-mode-card {
            margin-top: auto;
            background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.3));
            border-radius: 16px;
            border: 2px solid rgba(255,255,255,0.25);
            padding: 14px 18px 18px 18px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.7);
        }
        #lobby-mode-head {
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-bottom:8px;
        }
        .mode-label {
            font-size: 13px;
            opacity: 0.85;
        }
        .mode-value {
            font-size: 18px;
        }
        #lobby-play-btn {
            margin-top: 8px;
            width: 100%;
            background: var(--gold);
            color: #000;
            border: 4px solid white;
            padding: 18px 0;
            font-size: 26px;
            font-family: 'Russo One',sans-serif;
            text-transform: uppercase;
            transform: skewX(-10deg);
            cursor: pointer;
            box-shadow: 0 10px 0 rgba(0,0,0,0.3);
            transition: transform 0.08s, box-shadow 0.08s, filter 0.18s;
        }
        #lobby-play-btn:hover {
            filter: brightness(1.1);
            transform: skewX(-10deg) translateY(-2px);
        }
        #lobby-play-btn:active {
            transform: skewX(-10deg) translateY(4px);
            box-shadow: 0 6px 0 rgba(0,0,0,0.3);
        }

        #lobby-bottom-bar {
            font-size: 11px;
            opacity: 0.75;
            margin-top: 6px;
            display:flex;
            justify-content:space-between;
        }

        /* --- HUD --- */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* TOP */
        #top-bar { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box; }
        #minimap-wrapper { display: flex; flex-direction: column; align-items: flex-end; }
        #minimap { width: 140px; height: 140px; border: 3px solid rgba(255,255,255,0.8); background: rgba(0,0,0,0.5); border-radius: 4px; margin-bottom: 5px; }
        #game-stats { background: rgba(0,0,0,0.6); color: white; padding: 5px 15px; border-radius: 4px; font-size: 16px; display: flex; gap: 15px; transform: skewX(-10deg); }

        /* STORM WIDGET */
        #storm-widget { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; color: white; }
        #storm-timer-box { background: rgba(0,0,0,0.6); padding: 2px 20px; border: 2px solid white; transform: skewX(-15deg); transition: border-color 0.5s; }
        #storm-timer { font-size: 36px; letter-spacing: 2px; }
        #storm-label { font-size: 12px; margin-top: 4px; color: #ddd; text-shadow: 1px 1px 0 #000; }

        /* CAST BAR */
        #cast-bar-container {
            position: absolute; top: 65%; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: rgba(0,0,0,0.7); border: 2px solid white;
            display: none; border-radius: 4px;
        }
        #cast-fill { height: 100%; width: 0%; background: #ffff00; transition: width linear; }
        #cast-text { position: absolute; top: -25px; left: 50%; transform:translateX(-50%); color: white; font-size: 14px; text-shadow: 1px 1px 0 #000; font-weight: bold; width: 100%; text-align: center; }

        /* CENTER */
        #crosshair-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #reticle { width: 4px; height: 4px; background: white; border-radius: 50%; box-shadow: 0 0 3px black; }
        #reticle-spread { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; border: 2px solid rgba(255,255,255,0.7); border-radius: 50%; transition: all 0.1s; opacity: 0.5; }

        /* ALERTS */
        #interaction { position: absolute; top: 55%; left: 50%; transform: translateX(-50%) skewX(-10deg); background: var(--gold); color: black; padding: 8px 20px; border: 3px solid white; font-size: 18px; display: none; box-shadow: 0 5px 10px rgba(0,0,0,0.3); font-weight:bold; }
        #big-alert { position: absolute; top: 20%; left: 50%; transform: translateX(-50%) skewX(-10deg); text-align: center; display: none; }
        #big-alert h2 { font-size: 64px; color: var(--gold); margin: 0; text-shadow: 4px 4px 0 black; -webkit-text-stroke: 2px black; }

        /* BOTTOM */
        #status-bars { position: absolute; bottom: 30px; left: 30px; width: 350px; display: flex; flex-direction: column; gap: 8px; }
        .bar-container { position: relative; width: 100%; height: 18px; background: rgba(0,0,0,0.6); transform: skewX(-20deg); border: 2px solid #333; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        .bar-val { position: absolute; top: -26px; left: 0; color: white; font-size: 22px; transform: skewX(20deg); text-shadow: 2px 2px 0 #000; }
        #shield-bar .bar-fill { background: linear-gradient(90deg, #2b95ff, #00d5ff); }
        #health-bar .bar-fill { background: linear-gradient(90deg, #45b845, #8aff8a); }

        #inventory-wrapper { position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        #controls-hint { color: #aaa; font-size: 12px; margin-bottom: 5px; background: rgba(0,0,0,0.5); padding: 2px 5px; }
        #mats-counter { color: white; font-size: 24px; display: flex; align-items: center; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px 20px; transform: skewX(-10deg); border-left: 5px solid #d2b48c; }
        #slots-container { display: flex; gap: 8px; }
        
        .inv-slot { width: 80px; height: 80px; background: rgba(20, 25, 45, 0.9); border: 1px solid #555; clip-path: polygon(10% 0, 100% 0, 100% 100%, 0% 100%); position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.1s; }
        .inv-slot.selected { transform: scale(1.15) translateY(-15px); background: rgba(60, 80, 120, 0.9); border: 3px solid white; z-index: 10; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .slot-icon { font-size: 32px; filter: drop-shadow(0 4px 2px rgba(0,0,0,0.5)); }
        .slot-key { position: absolute; top: 4px; left: 6px; font-size: 11px; color: #aaa; background:rgba(0,0,0,0.5); padding:1px 4px; border-radius:2px; }
        .slot-ammo { position: absolute; bottom: 2px; right: 5px; font-size: 16px; color: white; }
        .rarity-gradient { position: absolute; bottom: 0; left: 0; width: 100%; height: 6px; }

        #build-ui { position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%) skewX(-10deg); background: rgba(0, 60, 200, 0.8); color: white; padding: 10px 30px; border: 2px solid white; display: none; text-align: center; }
        #ammo-hud { position: absolute; bottom: 140px; right: 40px; text-align: right; color: white; display: none; }
        #ammo-hud-count { font-size: 48px; text-shadow: 2px 2px 0 black; }
        
        #float-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .dmg-num { position: absolute; font-size: 32px; font-weight: 900; -webkit-text-stroke: 1.5px black; animation: popUp 0.6s forwards; }
        @keyframes popUp { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 30% { transform: translate(-50%, -120%) scale(1.3); opacity: 1; } 100% { transform: translate(-50%, -150%) scale(1); opacity: 0; } }

        #victory-screen, #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; backdrop-filter: blur(5px); }
        .end-banner { background: linear-gradient(90deg, #0055cc, #0099ff); padding: 20px 100px; transform: skewX(-10deg) rotate(-2deg); border: 6px solid white; box-shadow: 0 20px 50px rgba(0,0,0,0.6); }
        .end-text { font-size: 90px; color: white; margin: 0; text-shadow: 5px 5px 0 black; line-height: 0.9; text-align: center; }
        
        #storm-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none; background: radial-gradient(circle, transparent 60%, rgba(140,0,255,0.4) 100%); z-index: 100; }

        button { font-family: 'Russo One', sans-serif; }
    </style>
</head>
<body>

    <div id="title-screen">
        <div id="fortnite-logo">FORTNITE</div>
        <button id="start-btn">PLAY</button>
        <div style="color:white; margin-top:15px; opacity:0.8;">V39.0 - AUDIO & STORM UPDATE</div>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="lobby-screen">
        <div id="lobby-top-bar">
            <div id="lobby-title" class="fn-text">BATTLE ROYALE</div>
            <div id="lobby-tabs" class="fn-text">
                <span>PLAY</span>
                <span>BATTLE PASS</span>
                <span>CHALLENGES</span>
                <span>COMPETE</span>
                <span>LOCKER</span>
                <span>SHOP</span>
                <span>CAREER</span>
            </div>
        </div>

        <div id="lobby-main">
            <!-- Squad / party cards -->
            <div id="lobby-party">
                <!-- Left slot -->
                <div class="party-slot party-left party-empty">
                    <div class="party-banner banner-pink"></div>
                    <div class="party-character">
                        <div class="party-stand"></div>
                    </div>
                    <div class="party-footer">
                        <div class="party-name">Empty</div>
                        <div class="party-state">Not ready</div>
                    </div>
                </div>

                <!-- Center (player) -->
                <div class="party-slot party-center">
                    <div class="party-banner banner-teal"></div>
                    <div class="party-character">
                        <div class="party-stand"></div>
                        <!-- actual 3D character is in the scene; this is just the stand -->
                    </div>
                    <div class="party-footer">
                        <div class="party-name" id="player-name-label">NOBLE</div>
                        <div class="party-state">Not ready</div>
                    </div>
                </div>

                <!-- Right slots -->
                <div class="party-slot party-right party-empty">
                    <div class="party-banner banner-yellow"></div>
                    <div class="party-character">
                        <div class="party-stand"></div>
                    </div>
                    <div class="party-footer">
                        <div class="party-name">Empty</div>
                        <div class="party-state">Not ready</div>
                    </div>
                </div>

                <div class="party-slot party-far party-empty">
                    <div class="party-banner banner-purple"></div>
                    <div class="party-character">
                        <div class="party-stand"></div>
                    </div>
                    <div class="party-footer">
                        <div class="party-name">Empty</div>
                        <div class="party-state">Not ready</div>
                    </div>
                </div>

                <!-- Skin switcher -->
                <div id="skin-switcher" class="fn-text">
                    <button class="skin-arrow" id="skin-prev">â—€</button>
                    <span id="skin-name">NOBLE</span>
                    <button class="skin-arrow" id="skin-next">â–¶</button>
                </div>
            </div>

            <!-- Right-side info -->
            <div id="lobby-side">
                <div id="lobby-season-card">
                    <h3 class="fn-text" style="transform:none; text-shadow:1px 1px 0 #000;">SEASON 9</h3>
                    <div class="season-row">
                        <span>LEVEL 36</span>
                        <span>4,360 / 12,570 XP</span>
                    </div>
                    <div class="xp-bar"><div class="xp-fill"></div></div>
                    <div style="margin-top:8px; font-size:12px; font-weight:bold;">DAILY CHALLENGES</div>
                    <div class="challenge-row">
                        <span>Place Top 25 in Solo</span><span>0 / 1</span>
                    </div>
                    <div class="challenge-row">
                        <span>Place Top 50 in Solo</span><span>2 / 3</span>
                    </div>
                    <div class="challenge-row">
                        <span>SMG Eliminations</span><span>3 / 9</span>
                    </div>
                </div>

                <div id="lobby-mode-card">
                    <div id="lobby-mode-head">
                        <div>
                            <div class="mode-label fn-text" style="font-size:11px;">MODE</div>
                            <div class="mode-value fn-text" style="font-size:20px;">SQUADS</div>
                        </div>
                        <div style="text-align:right;">
                            <div class="mode-label fn-text" style="font-size:11px;">FILL</div>
                            <div class="mode-value fn-text" style="font-size:16px;">ON</div>
                        </div>
                    </div>
                    <button id="lobby-play-btn">PLAY</button>
                </div>
            </div>
        </div>

        <div id="lobby-bottom-bar">
            <div>Tip: Press <strong>Shift</strong> to sprint, <strong>F</strong> to build, <strong>E</strong> to interact.</div>
            <div>ESC for mouse cursor â€¢ SPACE for actions</div>
        </div>
    </div>

    <div id="game-container">
        <div id="storm-overlay"></div>
        <div id="hud-layer">
            <div id="top-bar">
                <div id="storm-widget">
                    <div id="storm-timer-box"><span id="storm-timer">01:00</span></div>
                    <span id="storm-label" class="fn-text">LOOT PHASE</span>
                </div>
                <div id="minimap-wrapper">
                    <div id="minimap"><canvas id="minimap-canvas" width="130" height="130"></canvas></div>
                    <div id="game-stats"><span>ðŸ’€ <span id="kills">0</span></span><span>ðŸ‘¥ <span id="alive">50</span></span></div>
                </div>
            </div>

            <div id="crosshair-container">
                <div id="reticle"></div>
                <div id="reticle-spread"></div>
            </div>
            <div id="float-container"></div>
            <div id="big-alert" class="fn-text"><h2 id="alert-text">COMBAT ACTIVATED!</h2></div>
            
            <!-- Interactions -->
            <div id="interaction" class="fn-text">E : OPEN</div>
            <div id="cast-bar-container">
                <div id="cast-text">USING...</div>
                <div id="cast-fill"></div>
            </div>
            
            <div id="build-ui">
                <div style="font-size:14px; color:#aaa;">BUILDING</div>
                <div id="build-current" class="fn-text" style="font-size:28px; color:yellow;">WALL</div>
                <div style="font-size:12px; margin-top:5px;">RIGHT CLICK TO CHANGE</div>
            </div>

            <div id="status-bars">
                <div class="bar-container" id="shield-bar"><div class="bar-val" id="shield-txt">0</div><div class="bar-fill" id="shield-fill" style="width: 0%"></div></div>
                <div class="bar-container" id="health-bar"><div class="bar-val" id="health-txt">100</div><div class="bar-fill" id="health-fill" style="width: 100%"></div></div>
            </div>

            <div id="ammo-hud" class="fn-text"><div id="ammo-hud-count">30</div><div style="font-size: 14px; color:#ccc;">AMMO</div></div>

            <div id="inventory-wrapper">
                <div id="controls-hint">X: Drop | E: Interact | F: Build</div>
                <div id="mats-counter" class="fn-text">ðŸªµ <span id="wood-val">0</span></div>
                <div id="slots-container"></div>
            </div>
        </div>

        <div id="victory-screen">
            <div class="end-banner"><h1 class="end-text fn-text">#1 VICTORY<br>ROYALE</h1></div>
            <button id="victory-restart" style="margin-top:40px; padding:15px 30px; font-size:20px; font-weight:bold; cursor:pointer;">RETURN TO LOBBY</button>
        </div>
        <div id="death-screen">
            <h1 style="color:red; font-size:100px; text-shadow:4px 4px 0 black;" class="fn-text">ELIMINATED</h1>
            <button id="death-restart" style="margin-top:20px; padding:15px 30px; font-size:20px; font-weight:bold; cursor:pointer;">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- AUDIO SYSTEM (ZZFX + ASSETS) ---
        const zzfxV=0.3;
        const zzfx=e=>{const t=zzfxP(e);t.buffer=zzfxG(...e);t.connect(zzfxX.destination);t.start();return t};
        const zzfxP=e=>{const t=zzfxX.createBufferSource();return t};
        const zzfxG=(e=1,t=.05,n=220,s=0,o=0,a=.1,r=0,c=1,l=0,i=0,d=0,u=0,h=0,f=0,m=0,p=0,g=0,b=1,x=0,C=0)=>{
            const M=2*Math.PI,y=44100,v=y*t;
            const S=zzfxX.createBuffer(1,v,y);
            const _=S.getChannelData(0);
            for(let k=0;k<v;k++){
                let w=k/v,T=k/(y/n);
                let P=s?s>0?1-Math.cos(w*M*s):1+Math.sin(w*M*s):1;
                let E=P>0?1:-1;P=E*Math.abs(P)**c;
                let A=o*M*w;let B=Math.sin(A)*a;let L=Math.cos(A)*a;
                let R=Math.sin(T*M+B)*P+L;_[k]=R*e*(1-w)
            }
            return S
        };
        const zzfxX=new(window.AudioContext||window.webkitAudioContext);

        const SOUNDS = {
            win: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/Fortnite%20Victory%20Royale%20-%20QuickSounds.com.mp3'),
            gun: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/ar-epic-shot-1.mp3'),
            chug: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/fortnite-shield-potion-fortnite-battle-royale-gaming-sound-effect-hd-sound-effects.mp3'),
            chest: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/fortnite.mp3'),
            storm: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/shtorm_eyeincoming.mp3'),
            death: new Audio('https://raw.githubusercontent.com/bellasaunders25/Game-Asset/main/tmp_7901-951678082.mp3')
        };
        SOUNDS.chest.loop = true;
        SOUNDS.chest.volume = 0;
        SOUNDS.gun.volume = 0.4;
        SOUNDS.death.volume = 0.6;

        // Lobby music & UI click sound
        const lobbyMusic = new Audio('https://github.com/bellasaunders25/Game-Asset/raw/refs/heads/main/videoplayback.mp3');
        lobbyMusic.loop = true;
        lobbyMusic.volume = 0.6;

        const uiClickBase = new Audio('https://github.com/bellasaunders25/Game-Asset/raw/refs/heads/main/Fortnite%20Mouse%20Button%20Click.mp3');

        function playUiSound(vol = 0.8) {
            try {
                const a = uiClickBase.cloneNode();
                a.volume = vol;
                a.play();
                setTimeout(() => {
                    if (!a.paused) a.pause();
                }, 1950); // ~2s
            } catch (e) {
                console.log('UI sound error', e);
            }
        }

        // ZZFX Sound Generators
        const playPickaxe = () => zzfx([1,.05,200,.03,.05,.1,2,1.4,.1]); // Thud
        const playBuild   = () => zzfx([1,.05,400,0,.1,.1,0,1.5,.1]); // Build click
        const playHit     = () => zzfx([1,.05,100,.05,.1,.4,4,2,.1]); // Hit

        const playStepWalk = () => zzfx([1,,80,.04,,.15,3,1.5,,,,,,,.3,,.4]);   // Footstep walk
        const playStepRun  = () => zzfx([1,,110,.035,,.12,3,1.8,,,,,,,.3,,.5]); // Footstep run
        const playJump     = () => zzfx([1,,260,.04,,.15,1,1.5,,,,,,,.4,,.7]);   // Jump
        const playLand     = () => zzfx([1,,90,.03,,.18,3,1.4,,,,,,,.4,,.6]);    // Landing thud
        const playBreak    = () => zzfx([1,,50,.06,,.3,3,1.5,,,,,,,.2,,.7]);     // Break object

        // CHARACTER SKINS
        const CHARACTER_SKINS = [
            { id: 'ranger', display: 'FAYRESS', bodyColor: 0xc49a6c, accentColor: 0x3e4e5c },
            { id: 'bimpaf', display: 'BIMPAF', bodyColor: 0x9ad5ff, accentColor: 0x2c3f4e },
            { id: 'noble',  display: 'NOBLE',  bodyColor: 0x4f77ff, accentColor: 0xe3f2fd },
            { id: 'djinn',  display: 'IDJINN', bodyColor: 0xc7b299, accentColor: 0x37474f }
        ];

        // --- GAME CONFIG ---
        const CONFIG = {
            SPEED: 0.16,
            GRAVITY: 0.015,
            JUMP: 0.42,
            SENSITIVITY: 0.002,
            WOOD_PER_TREE: 15,
            BUILD_COST: 10,
            RUN_MULT: 1.7
        };
        const RARITIES = {
            COMMON: { color: '#b0b0b0', name: 'Common', bg: '#888' },
            UNCOMMON: { color: '#33ff33', name: 'Uncommon', bg: '#4f4' },
            RARE: { color: '#00aaff', name: 'Rare', bg: '#4af' },
            EPIC: { color: '#cc00ff', name: 'Epic', bg: '#d0f' },
            LEGENDARY: { color: '#ffa500', name: 'Legendary', bg: '#fa0' }
        };

        const ITEMS = [
            { id: 'ar', name: 'AR-15', type: 'GUN', dmg: 30, rate: 110, ammo: 30, icon: 'ðŸ”«', spread: 0.02 },
            { id: 'smg', name: 'P90', type: 'GUN', dmg: 18, rate: 60, ammo: 40, icon: 'ðŸ–Šï¸', spread: 0.05 },
            { id: 'shotgun', name: 'Pump Shotgun', type: 'GUN', dmg: 95, rate: 900, ammo: 5, icon: 'ðŸ’¥', spread: 0.1, pellets: 5 },
            { id: 'sniper', name: 'Sniper', type: 'GUN', dmg: 150, rate: 1500, ammo: 1, icon: 'ðŸ”­', spread: 0.001 },
            { id: 'rpg', name: 'RPG', type: 'GUN', dmg: 110, rate: 2000, ammo: 1, icon: 'ðŸš€', spread: 0.01, explosive: true },
            { id: 'mini', name: 'Mini Potion', type: 'HEAL', val: 25, max: 50, time: 2000, icon: 'ðŸ§ª', target:'shield' },
            { id: 'big', name: 'Big Shield', type: 'HEAL', val: 50, max: 100, time: 5000, icon: 'ðŸº', target:'shield' },
            { id: 'chug', name: 'Chug Jug', type: 'HEAL', val: 100, max: 100, time: 10000, icon: 'ðŸº', target:'both' }
        ];
        
        const STORM_SEQ = [
            { w: 120, m: 60, r: 500 }, 
            { w: 120, m: 60, r: 200 },
            { w: 60, m: 45, r: 50 },
            { w: 0, m: 60, r: 0 }
        ];

        let gameState = 'MENU'; 
        let scene, camera, renderer, playerMesh, camPivot, stormMesh;
        let raycaster = new THREE.Raycaster();
        let player = { hp: 100, shield: 0, wood: 0, vy: 0, onGround: false, dead: false, kills: 0 };
        let enemies = [], interactables = [], bullets = [], walls = []; 
        let inventory = [{ type: 'PICKAXE', name: 'Pickaxe', icon: 'â›ï¸', rate: 400, rarity: 'COMMON' }, null, null, null, null];
        let slotIdx = 0, isBuildMode = false, buildIdx = 0, lastShot = 0, keys = {};
        
        let lootTimer = 60; 
        let stormRadius = 1000, phaseIdx = 0, stormState = 'WAIT', phaseTimer = STORM_SEQ[0].w; 
        let isCasting = false, castTimer = null, castEndTime = 0;

        let lastStepTime = 0;

        let playerSkinIndex = 2; // default "Noble"
        let playerCharacter = null;
        let playerHand = null;

        // --- CHARACTER / WEAPON MESH HELPERS ---
        function createCharacterMesh(skin) {
            const group = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({ color: skin.bodyColor, roughness: 0.6, metalness: 0.1 });
            const accentMat = new THREE.MeshStandardMaterial({ color: skin.accentColor, roughness: 0.3, metalness: 0.4 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), bodyMat);
            body.position.y = 1.4; body.castShadow = true; group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 18, 18), accentMat);
            head.position.y = 2.2; head.castShadow = true; group.add(head);

            // Hood / helmet ring
            const hood = new THREE.Mesh(new THREE.TorusGeometry(0.34, 0.06, 8, 16), accentMat);
            hood.position.y = 2.1; hood.rotation.x = Math.PI/2; hood.castShadow = true; group.add(hood);

            const armGeo = new THREE.BoxGeometry(0.22, 0.9, 0.25);
            const legGeo = new THREE.BoxGeometry(0.3, 1.1, 0.3);

            const armL = new THREE.Mesh(armGeo, bodyMat);
            armL.position.set(-0.6, 1.4, 0); armL.castShadow = true; group.add(armL);

            const armR = new THREE.Mesh(armGeo, bodyMat);
            armR.position.set(0.6, 1.4, 0); armR.castShadow = true; group.add(armR);

            const legL = new THREE.Mesh(legGeo, bodyMat);
            legL.position.set(-0.25, 0.45, 0); legL.castShadow = true; group.add(legL);

            const legR = new THREE.Mesh(legGeo, bodyMat);
            legR.position.set(0.25, 0.45, 0); legR.castShadow = true; group.add(legR);

            const handR = new THREE.Object3D();
            handR.position.set(0.16, -0.45, 0.12);
            armR.add(handR);

            group.userData.armL = armL;
            group.userData.armR = armR;
            group.userData.legL = legL;
            group.userData.legR = legR;
            group.userData.moving = false;
            group.userData.sprinting = false;

            return { mesh: group, hand: handR };
        }

        function createPickaxeMesh() {
            const g = new THREE.Group();
            const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.9, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.8 })
            );
            shaft.rotation.z = Math.PI/2;
            g.add(shaft);

            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.12, 0.18),
                new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.6, roughness: 0.3 })
            );
            head.position.set(0.25, 0, 0);
            g.add(head);

            g.rotation.z = -Math.PI/4;
            g.rotation.y = Math.PI/2;
            return g;
        }

        function createGunMesh(item) {
            const lengthMap = {
                ar: 0.9,
                smg: 0.7,
                shotgun: 0.85,
                sniper: 1.3,
                rpg: 1.1
            };
            const colorMap = {
                ar: 0x9e9e9e,
                smg: 0xff7043,
                shotgun: 0xffc107,
                sniper: 0x90caf9,
                rpg: 0x66bb6a
            };
            const length = lengthMap[item.id] || 0.8;
            const color  = colorMap[item.id]  || 0x9e9e9e;

            const g = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(length, 0.15, 0.18),
                new THREE.MeshStandardMaterial({ color, metalness: 0.5, roughness: 0.4 })
            );
            body.position.set(0, 0, 0);
            g.add(body);

            const grip = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 0.25, 0.12),
                new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.3, roughness: 0.7 })
            );
            grip.position.set(-length/4, -0.16, 0);
            g.add(grip);

            g.rotation.y = Math.PI/2;
            return g;
        }

        function equipWeapon(hand, itemOrType) {
            if (!hand) return;
            while (hand.children.length) hand.remove(hand.children[0]);
            if (!itemOrType) return;

            if (itemOrType === 'PICKAXE' || itemOrType.type === 'PICKAXE') {
                hand.add(createPickaxeMesh());
            } else if (itemOrType.type === 'GUN') {
                hand.add(createGunMesh(itemOrType));
            }
        }

        function updatePlayerWeaponModel() {
            if (!playerHand) return;
            const curItem = inventory[slotIdx];
            if (!curItem) {
                equipWeapon(playerHand, null);
            } else if (curItem.type === 'PICKAXE') {
                equipWeapon(playerHand, 'PICKAXE');
            } else {
                equipWeapon(playerHand, curItem);
            }
        }

        function applyPlayerSkin() {
            const skin = CHARACTER_SKINS[playerSkinIndex];
            document.getElementById('skin-name').innerText = skin.display.toUpperCase();
            document.getElementById('player-name-label').innerText = skin.display.toUpperCase();

            if (playerCharacter && playerMesh) {
                playerMesh.remove(playerCharacter);
            }
            const built = createCharacterMesh(skin);
            playerCharacter = built.mesh;
            playerHand = built.hand;
            if (playerMesh) {
                playerMesh.add(playerCharacter);
            }
            updatePlayerWeaponModel();
        }

        function animateCharacters(timeMs) {
            const t = timeMs * 0.005;
            function animateChar(char) {
                if (!char) return;
                const d = char.userData || {};
                const moving = !!d.moving;
                const sprinting = !!d.sprinting;
                const speed = moving ? (sprinting ? 9 : 6) : 2;
                const amp = moving ? (sprinting ? 0.8 : 0.5) : 0.12;
                const w = Math.sin(t * speed) * amp;

                if (d.armL && d.armR) {
                    d.armL.rotation.x = w;
                    d.armR.rotation.x = -w;
                }
                if (d.legL && d.legR) {
                    d.legL.rotation.x = -w * 0.7;
                    d.legR.rotation.x = w * 0.7;
                }
            }
            animateChar(playerCharacter);
            enemies.forEach(e => animateChar(e.mesh));
        }

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5080c0);
            scene.fog = new THREE.FogExp2(0x5080c0, 0.0015);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            playerMesh = new THREE.Group(); scene.add(playerMesh);
            camPivot = new THREE.Object3D(); camPivot.position.set(0, 1.7, 0); playerMesh.add(camPivot);
            camera.position.set(0.6, 0, 2); camPivot.add(camera);

            const amb = new THREE.AmbientLight(0xffffff, 0.7); scene.add(amb);
            const sun = new THREE.DirectionalLight(0xfff0dd, 0.9); 
            sun.position.set(100, 200, 50); sun.castShadow = true; 
            sun.shadow.mapSize.set(2048,2048); sun.shadow.camera.far = 500; 
            scene.add(sun);

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshToonMaterial({color: 0x44aa44}));
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

            const stormGeo = new THREE.CylinderGeometry(1, 1, 150, 32, 1, true);
            const stormMat = new THREE.MeshBasicMaterial({color: 0xaa00ff, transparent:true, opacity:0.4, side:THREE.DoubleSide});
            stormMesh = new THREE.Mesh(stormGeo, stormMat);
            stormMesh.position.y = 75; stormMesh.scale.set(stormRadius, 1, stormRadius);
            scene.add(stormMesh);

            genWorld();
            updateUI();
            applyPlayerSkin();

            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if(isCasting) cancelCast();
                if(e.code === 'KeyE') tryInteract();
                if(e.code === 'KeyX') dropItem();
                if(e.code === 'KeyF') toggleBuild();
                if(e.code.startsWith('Digit')) setSlot(parseInt(e.code.substr(5))-1);
            });
            document.addEventListener('keyup', e => keys[e.code] = false);
            document.addEventListener('mousedown', e => { 
                if(!document.pointerLockElement) return;
                if(e.button === 0) tryAction(); 
                if(e.button === 2 && isBuildMode) { buildIdx = (buildIdx+1)%3; updateUI(); }
            });
            document.addEventListener('mousemove', e => {
                if(document.pointerLockElement) {
                    playerMesh.rotation.y -= e.movementX * CONFIG.SENSITIVITY;
                    camPivot.rotation.x -= e.movementY * CONFIG.SENSITIVITY;
                    camPivot.rotation.x = Math.max(-1.4, Math.min(1.4, camPivot.rotation.x));
                }
            });

            const titleScreen = document.getElementById('title-screen');
            const startBtn = document.getElementById('start-btn');
            const lobbyScreen = document.getElementById('lobby-screen');
            const lobbyPlayBtn = document.getElementById('lobby-play-btn');

            const skinPrev = document.getElementById('skin-prev');
            const skinNext = document.getElementById('skin-next');

            // Title PLAY => open lobby
            startBtn.addEventListener('mouseenter', () => playUiSound(0.4));
            startBtn.addEventListener('click', () => {
                playUiSound(0.9);
                titleScreen.style.display = 'none';
                lobbyScreen.style.display = 'flex';
                zzfxX.resume();
                lobbyMusic.currentTime = 0;
                lobbyMusic.play().catch(e => console.log('Lobby music error', e));
            });

            // Lobby skin cycling
            skinPrev.addEventListener('click', () => {
                playUiSound(0.6);
                playerSkinIndex = (playerSkinIndex - 1 + CHARACTER_SKINS.length) % CHARACTER_SKINS.length;
                applyPlayerSkin();
            });
            skinNext.addEventListener('click', () => {
                playUiSound(0.6);
                playerSkinIndex = (playerSkinIndex + 1) % CHARACTER_SKINS.length;
                applyPlayerSkin();
            });

            // Lobby PLAY => start match
            lobbyPlayBtn.addEventListener('mouseenter', () => playUiSound(0.4));
            lobbyPlayBtn.addEventListener('click', () => {
                playUiSound(1);
                lobbyScreen.style.display = 'none';
                document.body.requestPointerLock();
                lobbyMusic.pause();
                lobbyMusic.currentTime = 0;
                SOUNDS.chest.play().catch(e=>console.log("Audio start fail", e));
                startPrepPhase();
            });

            // End screen buttons
            const victoryBtn = document.getElementById('victory-restart');
            const deathBtn = document.getElementById('death-restart');
            [victoryBtn, deathBtn].forEach(btn => {
                btn.addEventListener('mouseenter', () => playUiSound(0.4));
                btn.addEventListener('click', () => {
                    playUiSound(0.9);
                    location.reload();
                });
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        function genWorld() {
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.7, 4);
            const leafGeo = new THREE.ConeGeometry(3.5, 7, 6);
            const matTrunk = new THREE.MeshToonMaterial({color: 0x8b5a2b});
            const matLeaf = new THREE.MeshToonMaterial({color: 0x228b22});

            for(let i=0; i<150; i++) {
                const t = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, matTrunk); trunk.position.y = 2; trunk.castShadow = true;
                const leaf = new THREE.Mesh(leafGeo, matLeaf); leaf.position.y = 5.5; leaf.castShadow = true;
                t.add(trunk); t.add(leaf);
                let x = (Math.random()-0.5)*1200, z = (Math.random()-0.5)*1200;
                t.position.set(x,0,z); scene.add(t);
                walls.push({mesh:t, type:'TREE', hp:200});
            }

            for(let i=0; i<50; i++) {
                const skin = CHARACTER_SKINS[Math.floor(Math.random()*CHARACTER_SKINS.length)];
                const built = createCharacterMesh(skin);
                const enMesh = built.mesh;
                let x = (Math.random()-0.5)*600 + 50, z = (Math.random()-0.5)*600;
                enMesh.position.set(x, 0, z); enMesh.castShadow = true;
                scene.add(enMesh);
                enemies.push({
                    mesh: enMesh,
                    hand: built.hand,
                    hp: 100,
                    state: 'IDLE',
                    timer: 0,
                    lastShot: 0,
                    weapon: 'PICKAXE',
                    gunData: null
                });
                equipWeapon(built.hand, 'PICKAXE');
            }
            
            for(let i=0; i<50; i++) spawnChest((Math.random()-0.5)*900, (Math.random()-0.5)*900);
        }

        function spawnChest(x, z) {
            const chest = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(1, 0.6, 0.6), new THREE.MeshToonMaterial({color: 0xffbb00}));
            base.position.y = 0.3; base.castShadow = true;
            const lid = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.2, 0.65), new THREE.MeshToonMaterial({color: 0xdd9900}));
            lid.position.y = 0.65; 
            chest.add(base); chest.add(lid);
            chest.position.set(x, 0, z); chest.rotation.y = Math.random() * 6;
            
            const glow = new THREE.PointLight(0xffaa00, 1, 4); glow.position.y = 1; chest.add(glow);
            scene.add(chest);
            interactables.push({mesh:chest, type:'CHEST'});
        }

        function spawnItemDrop(pos, itemData) {
            if(!itemData) {
                const baseItem = ITEMS[Math.floor(Math.random()*ITEMS.length)];
                const rKeys = Object.keys(RARITIES);
                const rKey = rKeys[Math.floor(Math.random()*(rKeys.length-1))];
                itemData = {...baseItem, rarity: rKey};
            }
            const r = RARITIES[itemData.rarity];
            let geo;
            if(itemData.type === 'HEAL') geo = new THREE.CylinderGeometry(0.2, 0.2, 0.6);
            else geo = new THREE.BoxGeometry(0.6, 0.3, 0.1);

            const m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: r.color}));
            m.position.copy(pos); m.position.y = 0.5;
            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 10, 8, 1, true), new THREE.MeshBasicMaterial({color:r.color, transparent:true, opacity:0.3, side:THREE.DoubleSide}));
            beam.position.y = 5; m.add(beam);
            scene.add(m);
            interactables.push({mesh:m, type:'ITEM', data:itemData});
        }

        function startPrepPhase() {
            gameState = 'PREP';
            lootTimer = 60;
        }

        function startCombat() {
            gameState = 'PLAY';
            document.getElementById('storm-label').innerText = "STORM IN :";
            document.getElementById('storm-timer-box').style.borderColor = "white";
            document.getElementById('alert-text').innerText = "COMBAT ACTIVATED!";
            document.getElementById('big-alert').style.display = 'block';
            setTimeout(() => document.getElementById('big-alert').style.display = 'none', 3000);
            
            enemies.forEach(e => {
                if(e.mesh.children.length > 0) {
                    const first = e.mesh.children[0];
                    if(first.material && first.material.color) first.material.color.setHex(0xff0000);
                }
            });
            
            phaseIdx = 0; 
            stormState = 'WAIT'; 
            phaseTimer = STORM_SEQ[0].w;
        }

        function animate() {
            requestAnimationFrame(animate);
            if(player.dead) return;

            const dt = 0.016;
            const timeMs = (window.performance && performance.now) ? performance.now() : Date.now();

            if (gameState === 'PREP') {
                lootTimer -= dt;
                let sec = Math.ceil(lootTimer);
                document.getElementById('storm-timer').innerText = `00:${sec<10?'0'+sec:sec}`;
                if (lootTimer <= 0) startCombat();
            }

            updatePlayer();
            updateEnemies();
            updateBullets();
            updateStorm(dt);
            updateCast(dt);
            updateChestAudio();
            animateCharacters(timeMs);

            interactables.forEach(l => { l.mesh.rotation.y += 0.02; });
            renderer.render(scene, camera);
        }

        function updateChestAudio() {
            let minDist = 9999;
            for (let obj of interactables) {
                if (obj.type === 'CHEST') {
                    const d = playerMesh.position.distanceTo(obj.mesh.position);
                    if (d < minDist) minDist = d;
                }
            }
            if (minDist < 25) {
                let vol = (1 - (minDist / 25));
                SOUNDS.chest.volume = Math.max(0, Math.min(1, vol));
            } else {
                SOUNDS.chest.volume = 0;
            }
        }

        function updateStorm(dt) {
            if(gameState !== 'PLAY' || stormState === 'FINISHED') return;

            enemies.forEach(e => {
                const d = Math.sqrt(e.mesh.position.x**2 + e.mesh.position.z**2);
                if (d > stormRadius) {
                    if (Math.random() < 0.02) damageEntity(e, 2, false);
                }
            });

            phaseTimer -= dt;
            const min = Math.floor(Math.max(0, phaseTimer)/60);
            const sec = Math.floor(Math.max(0, phaseTimer)%60);
            document.getElementById('storm-timer').innerText = `${min}:${sec<10?'0'+sec:sec}`;
            const box = document.getElementById('storm-timer-box');

            if(stormState === 'WAIT') {
                document.getElementById('storm-label').innerText = "STORM IN :";
                box.style.borderColor = "white";
                
                if(phaseTimer <= 0) {
                    stormState = 'MOVE';
                    phaseTimer = STORM_SEQ[phaseIdx].m;
                    document.getElementById('alert-text').innerText = "STORM MOVING";
                    SOUNDS.storm.play().catch(e=>{});
                    document.getElementById('big-alert').style.display = 'block';
                    setTimeout(()=>document.getElementById('big-alert').style.display='none', 3000);
                }
            } else if (stormState === 'MOVE') {
                document.getElementById('storm-label').innerText = "MOVING !";
                box.style.borderColor = "#bd00ff";

                const targetR = STORM_SEQ[phaseIdx].r;
                const currentSpeed = (stormRadius - targetR) / (phaseTimer + 0.1) * dt;
                
                if(stormRadius > targetR) stormRadius -= currentSpeed;
                
                if(phaseTimer <= 0) {
                    stormRadius = targetR; 
                    phaseIdx++;
                    if(phaseIdx < STORM_SEQ.length) {
                        stormState = 'WAIT';
                        phaseTimer = STORM_SEQ[phaseIdx].w;
                    } else {
                        stormRadius = 0;
                        stormState = 'FINISHED';
                    }
                }
            }

            stormMesh.scale.set(stormRadius, 1, stormRadius);
            const dist = Math.sqrt(playerMesh.position.x**2 + playerMesh.position.z**2);
            const overlay = document.getElementById('storm-overlay');
            if(dist > stormRadius) {
                overlay.style.display = 'block';
                if(Math.random() < 0.03) damagePlayer(1);
            } else {
                overlay.style.display = 'none';
            }
        }

        // --- ACTIONS ---
        function startCast(duration, text, callback) {
            if(isCasting) return;
            isCasting = true;
            castEndTime = Date.now() + duration;
            const bar = document.getElementById('cast-bar-container');
            bar.style.display = 'block';
            document.getElementById('cast-text').innerText = text;
            castTimer = { duration: duration, cb: callback };
        }

        function updateCast(dt) {
            if(!isCasting) return;
            const now = Date.now();
            const remaining = castEndTime - now;
            const pct = 100 - (remaining / castTimer.duration * 100);
            document.getElementById('cast-fill').style.width = pct + '%';
            if(remaining <= 0) { castTimer.cb(); cancelCast(); }
        }

        function cancelCast() {
            isCasting = false;
            document.getElementById('cast-bar-container').style.display = 'none';
        }

        function tryAction() {
            if(isBuildMode) { doBuild(); return; }
            const item = inventory[slotIdx];
            if(!item) return;
            
            const now = Date.now();
            if(now - lastShot < item.rate) return;

            // --- PICKAXE ---
            if(item.type === 'PICKAXE') {
                camPivot.rotation.x -= 0.1; setTimeout(()=>camPivot.rotation.x+=0.1, 100);
                
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                raycaster.set(playerMesh.position.clone().add(new THREE.Vector3(0,1.7,0)), dir);
                
                const hits = raycaster.intersectObjects(scene.children, true);

                if(hits.length > 0 && hits[0].distance < 4) {
                    let hitObj = hits[0].object;
                    let hitWall = null;
                    let hitEnemy = null;
                    while(hitObj) {
                        if(!hitWall) hitWall = walls.find(w => w.mesh === hitObj);
                        if(!hitEnemy) hitEnemy = enemies.find(e => e.mesh === hitObj);
                        if(hitWall || hitEnemy) break;
                        hitObj = hitObj.parent;
                        if(hitObj && hitObj.type === 'Scene') break;
                    }

                    if(hitEnemy) {
                        playPickaxe();
                        damageEntity(hitEnemy, 40, true);
                    } else if(hitWall) {
                        playPickaxe();
                        hitWall.hp -= 50;
                        player.wood += CONFIG.WOOD_PER_TREE;
                        spawnDmgText(hits[0].point, `+${CONFIG.WOOD_PER_TREE}`, true);
                        hitWall.mesh.position.y -= 0.2; setTimeout(()=>hitWall.mesh.position.y+=0.2, 50);
                        
                        if(hitWall.hp <= 0) {
                            playBreak();
                            scene.remove(hitWall.mesh);
                            walls = walls.filter(w => w !== hitWall);
                        }
                        updateUI();
                    }
                }
                lastShot = now;
                return;
            }

            // --- GUN ---
            if(item.type === 'GUN' && item.ammo > 0) {
                item.ammo--;
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                if(SOUNDS.gun.currentTime > 0) SOUNDS.gun.currentTime = 0;
                SOUNDS.gun.play();
                shoot(playerMesh.position, dir, false, item);
                lastShot = now; updateUI();
            }
            // --- HEAL ---
            else if(item.type === 'HEAL') {
                 SOUNDS.chug.play().catch(e=>{});
                 startCast(item.time, "USING " + item.name, () => {
                    if(item.target === 'shield' || item.target === 'both') player.shield = Math.min(item.max, player.shield + item.val);
                    if(item.target === 'hp' || item.target === 'both') player.hp = Math.min(item.max, player.hp + item.val);
                    inventory[slotIdx] = null; updateUI();
                });
            }
        }

        function doBuild() {
            if(player.wood < CONFIG.BUILD_COST) return;
            player.wood -= CONFIG.BUILD_COST;
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const pPos = playerMesh.position;
            const target = pPos.clone().add(dir.multiplyScalar(4));
            let gx = Math.round(target.x/4)*4;
            let gz = Math.round(target.z/4)*4;
            let gy = Math.floor((pPos.y + 1)/4)*4; 
            
            const mat = new THREE.MeshToonMaterial({color: 0x8b5a2b});
            let mesh;
            playBuild();

            if(buildIdx === 0) { 
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.2), mat);
                let angle = Math.abs(dir.z) > Math.abs(dir.x) ? 0 : Math.PI/2;
                mesh.rotation.y = angle; mesh.position.set(gx, gy+2, gz);
            } 
            else if(buildIdx === 1) { 
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 4), mat);
                mesh.position.set(gx, gy, gz);
            } 
            else if(buildIdx === 2) { 
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 5.8), mat);
                mesh.position.set(gx, gy+2, gz);
                let yRot = 0;
                if(Math.abs(dir.z) > Math.abs(dir.x)) yRot = dir.z > 0 ? 0 : Math.PI;
                else yRot = dir.x > 0 ? -Math.PI/2 : Math.PI/2;
                mesh.rotation.set(-Math.PI/4, yRot, 0);
            }
            scene.add(mesh);
            walls.push({mesh:mesh, hp:150, type:'BUILD'});
            updateUI();
        }

        function tryInteract() {
            let near = interactables.find(x => playerMesh.position.distanceTo(x.mesh.position) < 3.5);
            if(near) {
                if(near.type === 'CHEST') {
                    startCast(2000, "OPENING CHEST", () => {
                        spawnItemDrop(near.mesh.position, null); 
                        scene.remove(near.mesh); interactables = interactables.filter(x => x !== near);
                    });
                } else if (near.type === 'ITEM') {
                    let idx = inventory.findIndex(s => s === null);
                    if(idx === -1) idx = slotIdx === 0 ? 1 : slotIdx; 
                    if(inventory[idx] !== null) spawnItemDrop(playerMesh.position, inventory[idx]);
                    inventory[idx] = near.data; 
                    scene.remove(near.mesh); interactables = interactables.filter(x => x !== near);
                    slotIdx = idx; updateUI();
                }
            }
        }

        function dropItem() {
            if(slotIdx === 0) return;
            const item = inventory[slotIdx];
            if(item) {
                spawnItemDrop(playerMesh.position, item);
                inventory[slotIdx] = null; updateUI();
            }
        }

        function shoot(pos, dir, isEnemy, itemData) {
            const mat = new THREE.MeshBasicMaterial({color: isEnemy ? 0xff0000 : 0xffff00});
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.6), mat);
            b.position.copy(pos).add(new THREE.Vector3(0, 1.5, 0));
            b.lookAt(b.position.clone().add(dir)); scene.add(b);
            
            let dmg = isEnemy ? (itemData ? itemData.dmg : 10) : itemData.dmg;
            if(!isEnemy) {
                camPivot.rotation.x += 0.02;
                const el = document.getElementById('reticle-spread'); 
                el.style.width = (24 + itemData.spread*100) + 'px'; el.style.height = (24 + itemData.spread*100) + 'px';
                setTimeout(() => { el.style.width='24px'; el.style.height='24px'; }, 150);
            }
            bullets.push({mesh:b, vel:dir.multiplyScalar(3), life:60, isEnemy:isEnemy, dmg:dmg});
        }

        function updateBullets() {
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                b.mesh.position.add(b.vel); b.life--;
                
                let hit = false;
                if(!b.isEnemy) { 
                    for(let e of enemies) {
                        if(b.mesh.position.distanceTo(e.mesh.position) < 2.5) {
                            damageEntity(e, b.dmg, true); scene.remove(b.mesh); bullets.splice(i,1); hit=true; break;
                        }
                    }
                } else { 
                     if(b.mesh.position.distanceTo(playerMesh.position) < 2.0) {
                        damagePlayer(b.dmg); scene.remove(b.mesh); bullets.splice(i,1); hit=true;
                    }
                    if(!hit) {
                        for(let e of enemies) {
                            if(b.mesh.position.distanceTo(e.mesh.position) < 2.5) {
                                e.hp -= b.dmg;
                                if(e.hp<=0) killEnemy(e);
                                scene.remove(b.mesh); bullets.splice(i,1); hit=true; break;
                            }
                        }
                    }
                }
                if(hit) continue;
                if(b.mesh.position.y < 0) { scene.remove(b.mesh); bullets.splice(i,1); continue; }
                if(b.life<=0) { scene.remove(b.mesh); bullets.splice(i,1); }
            }
        }

        function damageEntity(e, dmg, isCrit) {
            playHit();
            e.hp -= dmg; spawnDmgText(e.mesh.position, dmg, isCrit);
            if(e.hp <= 0) killEnemy(e);
        }
        
        function killEnemy(e) {
             if(e.mesh.position.distanceTo(playerMesh.position) < 40) {
                 if(SOUNDS.death.currentTime > 0) SOUNDS.death.currentTime = 0;
                 SOUNDS.death.play().catch(err=>{});
             }
             scene.remove(e.mesh); enemies = enemies.filter(en => en !== e);
             player.kills++; spawnItemDrop(e.mesh.position, null); updateUI();
             if(enemies.length === 0) {
                 SOUNDS.win.play();
                 document.getElementById('victory-screen').style.display='flex';
             }
        }
        
        function damagePlayer(dmg) {
            playHit();
            if(player.shield > 0) { player.shield -= dmg; if(player.shield < 0) { player.hp += player.shield; player.shield = 0; } } 
            else { player.hp -= dmg; }
            updateUI();
            const div = document.createElement('div'); div.style.cssText = 'position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(255,0,0,0.2); pointer-events:none;'; 
            document.body.appendChild(div); setTimeout(()=>div.remove(), 100);
            if(player.hp <= 0) { 
                SOUNDS.death.play();
                document.exitPointerLock(); document.getElementById('death-screen').style.display='flex'; 
            }
        }
        function spawnDmgText(pos, val, crit) {
            const div = document.createElement('div'); div.className = 'dmg-num'; div.innerText = val;
            div.style.color = crit ? '#ffff00' : 'white';
            const vec = pos.clone().add(new THREE.Vector3(0,2,0)).project(camera);
            div.style.left = (vec.x*0.5+0.5)*window.innerWidth + 'px';
            div.style.top = (-vec.y*0.5+0.5)*window.innerHeight + 'px';
            document.getElementById('float-container').appendChild(div);
            setTimeout(() => div.remove(), 600);
        }
        
        function updatePlayer() {
            if(!document.pointerLockElement) return;
            const now = (window.performance && performance.now) ? performance.now() : Date.now();
            const prevGrounded = player.onGround;

            const isSprinting = (keys['ShiftLeft'] || keys['ShiftRight']);
            let speed = CONFIG.SPEED * (isSprinting ? CONFIG.RUN_MULT : 1);
            let moving = false;

            if(keys['KeyW']) { playerMesh.translateZ(-speed); moving = true; }
            if(keys['KeyS']) { playerMesh.translateZ(speed);  moving = true; }
            if(keys['KeyA']) { playerMesh.translateX(-speed); moving = true; }
            if(keys['KeyD']) { playerMesh.translateX(speed);  moving = true; }

            player.vy -= CONFIG.GRAVITY;
            playerMesh.position.y += player.vy;
            player.onGround = false;

            if(playerMesh.position.y < 0) {
                playerMesh.position.y = 0;
                player.vy = 0;
                player.onGround = true;
            }

            raycaster.set(playerMesh.position.clone().add(new THREE.Vector3(0,1.8,0)), new THREE.Vector3(0,-1,0));
            let hits = raycaster.intersectObjects(walls.map(w=>w.mesh));
            if(hits.length > 0 && hits[0].distance < 1.9 && player.vy <= 0) {
                playerMesh.position.y = hits[0].point.y;
                player.vy = 0;
                player.onGround = true;
            }

            if(keys['Space'] && player.onGround) {
                player.vy = CONFIG.JUMP;
                player.onGround = false;
                playJump();
            }

            if(!prevGrounded && player.onGround) {
                playLand();
            }

            if(playerCharacter) {
                playerCharacter.userData.moving = moving;
                playerCharacter.userData.sprinting = isSprinting;
            }

            if(player.onGround && moving) {
                const interval = isSprinting ? 230 : 350;
                if(now - lastStepTime > interval) {
                    if(isSprinting) playStepRun(); else playStepWalk();
                    lastStepTime = now;
                }
            }

            let near = interactables.find(l => playerMesh.position.distanceTo(l.mesh.position) < 3.5);
            const intDiv = document.getElementById('interaction');
            if(near) {
                intDiv.style.display = 'block';
                intDiv.innerText = near.type === 'CHEST' ? "E : OPEN CHEST" : "E : PICK UP " + near.data.name;
            } else intDiv.style.display = 'none';
        }

        function enemyLootCheck(e) {
            if(e.weapon !== 'PICKAXE') return;
            let chestIndex = -1;
            for(let i=0;i<interactables.length;i++) {
                const obj = interactables[i];
                if(obj.type === 'CHEST' && e.mesh.position.distanceTo(obj.mesh.position) < 3.2) {
                    chestIndex = i; break;
                }
            }
            if(chestIndex === -1) return;

            const chest = interactables[chestIndex];
            const gunPool = ITEMS.filter(it => it.type === 'GUN');
            const base = gunPool[Math.floor(Math.random()*gunPool.length)];
            const gun = {...base};
            gun.ammo = base.ammo * 2;
            e.weapon = 'GUN';
            e.gunData = gun;
            equipWeapon(e.hand, gun);

            scene.remove(chest.mesh);
            interactables.splice(chestIndex,1);
        }

        // --- AI LOGIC (WAR + PREP) ---
        function updateEnemies() {
            const now = Date.now();
            enemies.forEach(e => {
                if(e.mesh.position.y > 0) e.mesh.position.y -= 0.1; else e.mesh.position.y = 0;
                
                if (gameState === 'PREP') {
                    e.timer--; 
                    if(e.timer<=0) { e.rot = Math.random()*Math.PI*2; e.timer=80; }
                    e.mesh.rotation.y = e.rot; e.mesh.translateZ(0.1);
                    e.mesh.userData.moving = true;
                    enemyLootCheck(e);
                    return;
                }
                
                if(gameState === 'PLAY') {
                    let target = null;
                    let minDist = 200;

                    const dPlayer = e.mesh.position.distanceTo(playerMesh.position);
                    if(dPlayer < minDist) { target = { pos: playerMesh.position, isPlayer:true }; minDist = dPlayer; }

                    for(let i=0; i<10; i++) {
                         const other = enemies[Math.floor(Math.random()*enemies.length)];
                         if(other !== e && other.hp > 0) {
                             const d = e.mesh.position.distanceTo(other.mesh.position);
                             if(d < minDist) { target = { pos: other.mesh.position, enemyRef: other }; minDist = d; }
                         }
                    }

                    if(target) {
                         e.mesh.lookAt(target.pos.x, e.mesh.position.y, target.pos.z);
                         if(minDist > 5) {
                             e.mesh.translateZ(0.08);
                             e.mesh.userData.moving = true;
                         } else {
                             e.mesh.userData.moving = false;
                         }

                         if(e.weapon === 'GUN' && e.gunData) {
                             if(now - e.lastShot > e.gunData.rate) {
                                 const dir = new THREE.Vector3().subVectors(target.pos, e.mesh.position).normalize();
                                 shoot(e.mesh.position, dir, true, e.gunData);
                                 e.lastShot = now;
                             }
                         } else { // pickaxe melee
                             if(minDist < 3.2 && now - e.lastShot > 700) {
                                 if(target.isPlayer) damagePlayer(15);
                                 else if(target.enemyRef) damageEntity(target.enemyRef, 20, true);
                                 e.lastShot = now;
                             }
                         }
                    } else {
                        e.timer--; if(e.timer<=0) { e.rot = Math.random()*Math.PI*2; e.timer=100; }
                        e.mesh.rotation.y = e.rot; e.mesh.translateZ(0.05);
                        e.mesh.userData.moving = true;
                    }

                    enemyLootCheck(e);
                }
            });
        }

        function updateUI() {
            document.getElementById('health-fill').style.width = player.hp + '%'; document.getElementById('health-txt').innerText = Math.ceil(player.hp);
            document.getElementById('shield-fill').style.width = player.shield + '%'; document.getElementById('shield-txt').innerText = Math.ceil(player.shield);
            document.getElementById('wood-val').innerText = player.wood;
            document.getElementById('kills').innerText = player.kills; document.getElementById('alive').innerText = enemies.length + 1;
            document.getElementById('build-ui').style.display = isBuildMode ? 'block' : 'none';
            document.getElementById('build-current').innerText = ["WALL", "FLOOR", "RAMP"][buildIdx];
            
            const con = document.getElementById('slots-container'); con.innerHTML = '';
            inventory.forEach((item, i) => {
                const d = document.createElement('div'); d.className = 'inv-slot ' + (i === slotIdx && !isBuildMode ? 'selected' : '');
                let inner = `<span class="slot-key">${i+1}</span>`;
                if(item) {
                    inner += `<div class="rarity-gradient" style="background:${item.rarity ? RARITIES[item.rarity].bg : '#555'}"></div>`;
                    inner += `<div class="slot-icon">${item.icon}</div>`;
                    if(item.ammo !== undefined) inner += `<span class="slot-ammo">${item.ammo}</span>`;
                }
                d.innerHTML = inner; con.appendChild(d);
            });
            const cur = inventory[slotIdx];
            document.getElementById('ammo-hud').style.display = (cur && cur.ammo!==undefined) ? 'block' : 'none';
            if(cur && cur.ammo!==undefined) document.getElementById('ammo-hud-count').innerText = cur.ammo;

            updatePlayerWeaponModel();
        }
        function setSlot(i) { if(i>=0 && i<5) { slotIdx = i; isBuildMode = false; cancelCast(); updateUI(); } }
        function toggleBuild() { isBuildMode = !isBuildMode; cancelCast(); updateUI(); }

        init();
    </script>
</body>
</html>
